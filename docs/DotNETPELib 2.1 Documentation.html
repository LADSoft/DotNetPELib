<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>DotNETPELib 2.1 Documentation</title>
  </head>
  <body>
    <div align="center"><font size="+3">DotNetPELib 2.1 Documentation<br>
      </font>
      <div align="left"><br>
        DotNETPELib is an unmanaged library written in C++, which allows
        generation of .NET assemblies from C++ programs.&nbsp;&nbsp; It
        has full support for creating namespaces, classes, fields,
        methods, method bodies, and some advanced features such as
        support for explicit classes and properties. &nbsp; Full support
        for PInvoke is available for calling unmanaged DLL entry
        points.&nbsp;&nbsp; This library uses the ECMA-335 standard as a
        reference for the implementation, but also supports later
        versions of .NET assemblies.<br>
        <br>
        DotNETPELib also natively supports the 'argument array' and
        'enumeration' features of C#. &nbsp; <br>
        <br>
        Code generated by DotNETPELib may be accessed from other .NET
        assemblies, and there is also full support for importing other
        assemblies in order to access their fields and
        methods.&nbsp;&nbsp; In the simplest case, one can import an
        assembly then search for declarations of interest using various
        search functions.&nbsp;&nbsp; The declaration will then be used
        later by the library when generating references needed by your
        program.&nbsp;&nbsp; In more advanced case, one can iterate
        through all the definitions in an assembly and put them in a
        separate symbol table.&nbsp;&nbsp; For example the occil
        compiler copies all the static functions in referenced
        assemblies into its own symbol table then allows one to access
        them in C code using standard C++ semantics.<br>
        <br>
        DotNetPELib 2.1 also allows signing an assembly, if one has a
        strong name key file describing the signing keys.<br>
        <br>
        As an output format, DotNETPELib currently supports .NET
        assemblies in both EXE and DLL format.&nbsp;&nbsp; It will both
        read and write them.&nbsp;&nbsp; It will also generate a .IL
        formatted file which can be further compiled with the standard
        .NET ILASM program to generate an assembly.<br>
        <br>
        A reference implementation of a C compiler called 'occil' makes
        use of this library to generate managed assemblies.<br>
        <br>
        This documentation will consider the available APIs in
        DotNetPELib 2.1.<br>
        <br>
        <div align="center"><font size="+2">Overview</font><br>
        </div>
        <br>
        <br>
        The DotNetPELib api is wrapped in the C++ namespace <b>DotNetPELib</b>
        for isolation from other libraries.&nbsp;&nbsp; <br>
        <br>
        DotNetPELib will manage memory if that is desirable; most of the
        classes described in this documentation have their constructors
        wrapped by an object of class <a href="Allocator.html">Allocator</a>.&nbsp;&nbsp;
        When this object is destroyed, it will call the destructor for
        each allocated item then release its memory.&nbsp; In this way
        the user is freed from keeping track of every created object.<br>
        <br>
        An object of type <a href="PELibError.html">PELibError</a> may
        be thrown during validation of MSIL code.<br>
        <br>
        The main API is an object derived from the <a href="PELib.html">PELib</a>
        class.&nbsp; PELib inherits from Allocator, which exposes all
        the constructors for the other elements of the AI.&nbsp;&nbsp;
        Between that and the various utility functions it exposes, PELib
        is usually the main entry point for creating things with the API
        or probing existing values.<br>
        <br>
        <a href="AssemblyDef.html">AssemblyDef</a> objects are the
        high-level objects that hold the data for each
        assembly.&nbsp;&nbsp; An AssemblyDef can be either internally
        generated, or loaded from an external source.&nbsp;&nbsp; With
        DotNetPELib there will be one 'public' AssemblyDef object that
        describes the assembly being generated, and one or more external
        AssemblyDef objects which describe other assemblies.&nbsp;&nbsp;
        It is possible to load an external assembly into an AssemblyDef
        object, or one can explicitly write the data for an external
        assembly in through code.&nbsp;&nbsp; For example 'mscorlib'
        could be loaded and would be considered an external assembly.<br>
        <br>
        To be compatible with C# an AssemblyDef object would usually
        hold one or more <a href="Namespace.html">Namespace</a>
        objects, however, for applications that don't need to be
        compatible it is possible to just start putting fields and
        methods into the main AssemblyDef.&nbsp;&nbsp; One cannot put
        Properties in an AssemblyDef though<br>
        <br>
        A Namespace object will normally hold one or more <a
          href="Class.html">Class</a> or <a href="Enum.html">Enum</a>
        objects.&nbsp;&nbsp; A Class object can hold other Class and
        Enum objects, and it can also hold various other types of
        endpoint objects such as a <a href="Method.html">Method</a>, a
        <a href="Field.html">Field</a>, or a <a href="Property.html">Property</a>.&nbsp;&nbsp;
        An Enum object just holds Field objects that describe the
        enumerated values.<br>
        <br>
        The AssemblyDef, Class, Enum, and Namespace classes all inherit
        from a base class <a href="DataContainer.html">DataContainer </a>which
        holds functionality which is common between all those
        classes.&nbsp;&nbsp; A related class <a href="Qualifier.html">Qualifier</a>
        holds qualifier flags for various containers and other objects,
        such as whether the container defines an object or a value type,
        whether an object is static, etc..<br>
        <br>
        The Field object holds a <a href="Type.html">Type</a> object
        describing the field type, and possibly initialization
        data.&nbsp;&nbsp; Fields are also used when describing
        enumerated values.<br>
        <br>
        The Method object holds a <a href="MethodSignature.html">MethodSignature</a>
        which describes the way the method looks to other code, and it
        also holds a list of <a href="Instruction.html">Instruction</a>
        objects which describe the runtime behavior of the
        method.&nbsp;&nbsp; <br>
        <br>
        A base class <a href="CodeContainer.html">CodeContainer</a>
        actually holds most of the functionality related to MSIL
        instructions.&nbsp; The MSIL instruction capability is somewhat
        advanced.&nbsp; It optimizes which instructions get used in
        various cases where shorter instructions can be chosen, and
        checks stack balancing as a sanity check on the generated code.
        &nbsp; It also minimizes the size of the locals
        area.&nbsp;&nbsp; Live variable analysis is also performed, as
        an aid to the stack checking (dead regions might be unbalanced).<br>
        <br>
        The Instruction objects uniquely define MSIL instructions.
        &nbsp; An Instruction object can hold an <a href="Operand.html">Operand</a>
        object, which can hold a native object such as a number, string
        or label, or a reference to a variable, type, or method
        signature.<br>
        <br>
        Many Operand objects hold an instance of something derived from
        the <a href="Value.html">Value</a> class.&nbsp;&nbsp;&nbsp; The
        base Value object usually gets rendered as a type (e.g. a class
        instance) but the derivations get rendered different
        ways.&nbsp;&nbsp;&nbsp; For example a <a href="Local.html">Local</a>
        object describes a local variable, a <a href="Param.html">Param</a>
        object describes a parameter, a <a href="FieldName.html">FieldName</a>
        object references a Field object, and a <a
          href="MethodName.html">MethodName</a> object references a
        MethodSignature object.<br>
        &nbsp;<br>
        The MethodSignature object holds a Type object for the return
        type, a list of Param objects for the main parameter list, and
        optionally a second list of Param objects.&nbsp;&nbsp; This
        second list is only there to support unmanaged functions which
        utilize C-style variable length argument lists.<br>
        <br>
        An instance of an auxilliary class <a
          href="CustomAttributeContainer.html">CustomAttributeContainer</a>
        holds custom attributes read in from an assembly.&nbsp;&nbsp; In
        the current library implementation one can't add custom
        attributes to the generated code, with the exception that the
        library will automatically generate the custom attribute
        required for the parameter array, e.g. the C# version of
        variable length argument lists.<br>
        <br>
        A special object <a href="BoxedType.html">BoxedType</a> is used
        as an aid for boxing; it effectively transforms basic types into
        their boxed version.<br>
        <br>
        There are also two internal APIs used by the library; one is
        used for generating the binary version of .NET assemblies, and
        the other is used to load the binary version of .NET assemblies
        into internal memory.&nbsp;&nbsp; These APIs will not normally
        be directly used when utilizing the library to generate .NET
        assemblies, and are beyond the scope of this
        documentation.&nbsp;&nbsp; These APIs are described in the file
        PEFILE.h for those who would like to consider the
        implementation.<br>
        <br>
        <br>
        <br>
        <br>
        <br>
      </div>
    </div>
  </body>
</html>
